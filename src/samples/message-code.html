<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Message codé</title>
    <link rel="shortcut icon" href="../img/icon-design.png" type="image/png">

    <script src="../script/script.js"></script>

    <link rel="stylesheet" href="../style/style-projet.css">
    <link rel="stylesheet" href="../style/style-mid-projet.css">
    <link rel="stylesheet" href="../style/style-phone-projet.css">

</head>

<body>

    <header id="header-sticky">

        <div class="logo-sticky">
            <a href="https://anais-mez.github.io/Portfolio"><img src="../img/logo-header.png" alt="Logo header"></a>
        </div>

        <div class="items-sticky">
            <a href="#" class="menu-item active" onclick="setActive(this)">
                DESCRIPTION</a>
            <a href="#section-projet-schema" class="menu-item" onclick="setActive(this)">SCHEMA</a>
            <a href="#section-projet-quantification" class="menu-item" onclick="setActive(this)">QUANTIFICATION</a>
            <a href="#section-projet-programme1" class="menu-item" onclick="setActive(this)">PROGRAMME 1</a>
            <a href="#section-projet-programme2" class="menu-item" onclick="setActive(this)">PROGRAMME 2</a>
            <a href="#code-source" class="menu-item" onclick="setActive(this)">LIENS</a>
        </div>

        <button type="button" class="nav-toggler" onclick="toggleNav()" aria-label="toggle curtain navigation">
            <span class="line l1"></span>
            <span class="line l2"></span>
            <span class="line l3"></span>
        </button>

    </header>

    <main>
        <section id="section-projet-description">
            <img src="../img/signal.jfif" alt="Signaux sinudoïdales" id="img_message_code">

            <div class="text-projet">
                <h1>Message codé</h1>
                <h3>Python & Jupyter - 2021</h3>
                <p>
                    Nous sommes au département Recherche et Développement de l'agence AIL3C. L'agence a localisé la plus
                    grande organisation de cyberpirates du web. Cette organisation opère depuis une base secrète
                    localisée dans une giganteste chaîne de montagne.
                </p>
                <p>
                    L'agent K57 a réussi à s'introduire dans cette organisation malheureusement, il s'est retrouvé dans
                    une salle de conférence qui ne laissait passer aucunes ondes.
                </p>
                <p>
                    L'objectif est de trouver une solution qui aurait pu sauver l'agent K57. Soit trouver un moyen de
                    communication entre un homme bloqué dans une salle pourvue d'ondes et un autre chargé de récupérer
                    cette communication afin de pouvoir l'aider.
                </p>
            </div>
        </section>

        <section id="section-projet-schema">
            <h1>SCHEMA DE LA SEQUENCE DE TRANSMISSION</h1>
            <p>
                Ce schéma permet d'imager la transmission entre l'agent qui est dans la salle de réunion et l'agent qui
                doit réceptionner le message. Cette partie permettra de comprendre plus facilement le programme et
                pourquoi il a été construit de cette façon.
            </p>

            <h3>L'expediteur</h3>
            <p>
                L'expéditeur doit enregistrer son message dans le PAD puis l'envoyer. Un PAD est un traitement de texte
                collaboratif en ligne. Il permet à un groupe de personnes de partager simultanément un texte en cours
                d'élaboration.
            </p>

            <h3>Le PAD</h3>
            <p>
                Le PAD permet de coder et modulé le message. Nous choisirons donc d'envoyer un texte simple avec un
                encodage NRZ unipolaire et une modulation ASK. Il permettra le changement du numérique en
                analogique et aussi le changement du message fait de caractères en binaire. Il générera la trame.
            </p>

            <h3>Le micro</h3>
            <p>
                Le micro, lui, permettra d'enregistrer le signal sortant du PAD. Le micro enverra ensuite le signal sur
                le réseau de la base secrète et transformera donc le signal analogique en numérique.
            </p>

            <h3>Le reseau</h3>
            <p>
                Le réseau nous permettra l'envoie de l'information pour que l'agent chargé de l'écoute réceptionne le
                message envoyé.
            </p>

            <h3>L'ordinateur d'écoute</h3>
            <p>
                L'ordinateur chargé de l'écoute doit réceptionner le signal envoyer par l'agent, le démoduler en
                fonction de la modulation et la même chose avec l'encodage et le décodage. Il devra utiliser une table
                d'ASCII pour passer le message binaire en caractère.
            </p>

            <h3>L'opérateur AIL3C</h3>
            <p>
                L'opérateur devra lire le message et transmettre les données à l'agent présent à l'agence pour l'aider.
            </p>

        </section>


        <section id="section-projet-quantification">
            <h1>QUANTIFICATION DES DONNEES</h1>
            <p>
                Nous avons choisi une fréquence de 22 050Hz car elle n'est pas audible par l'oreille humaine afin de
                rester discret dans l'organisation ennemie. Donc avec le théorème de Nyquist-Shannon, on trouve une
                fréquence d'échantillonnage de 44 100Hz.
            </p>
            <p>
                Le type de modulation est une modulation ASK (Amplitude-Shift Keying) qui impactera l'amplitude de notre
                signal.
            </p>
            <p>
                Nous choisissons l'encodage NRZ unipolaire car c'est celui qui nous était le plus familier lors
                de la création de ce projet.
            </p>
            <p>
                Le type de communication sera asynchrone parce que ceci apporte une flexibilité, un meilleur contrôle de
                temps et une possibilité de réponse.
            </p>
            <p>
                Nous options pour un cas de trame PPP sur HDLC, dans cette configuration, une trame PPP est une trame
                HDLC à laquelle a été ajoutée un protocole servant à l'encapsulation des couches supérieures. L'avantage
                de cette configuration est qu'elle ne comporte pas de limite de stockage donc même un fichier volumineux
                pourra s'envoyer facilement et en une seule fois, seulement, le temps d'envoie sera un peu plus long
                qu'avec un fichier de taille habituelle.
            </p>
        </section>

        <section id="section-projet-programme1">
            <h1>PROGRAMME DE L'ORDINATEUR DE L'AGENT</h1>
            <h3>Initialisation des fonctions</h3>
            <code>
                import matplotlib.pyplot as plt <br>
                import numpy as np <br>
                %matplotlib inline <br>
                from numpy import genfromtxt
            </code>

            <h3>ASCII vers binaire</h3>
            <code>
                #Entrée du message à envoyer <br>
                message_input = input(str("Entrez le message à transmettre : ")) <br><br>

                #Fonction de conversion d'un string en binaire <br>
                message_input_bin = [int(bit) for bit in ''.join(format(ord(char), 'b').zfill(0) for char in message_input)] <br>
                print(message_input_bin) <br>
                print(len(message_input_bin))
            </code>

            <h3>Création de la trame</h3>
            <code>
                #Déclaration de la liste correspondant à la trame <br>
                ##trame_ppp = [] <br> <br>

                #Initialisation des listes correspondant aux éléments de la trame <br>
                ##fanion = [0,1,1,1,1,1,1,0] <br>
                ##adresse_D = [1,1,1,1,1,1,1,1] <br>
                ##control = [0,0,0,0,0,0,1,1] <br>
                ##protocol = [0,0,0,0,0,0,0,0] <br><br>

                ##CRC = [] <br><br>

                #Injection dans l'odre des éléments de la trame avant les données dans la trame <br>
                ##trame_ppp.extend(fanion) <br>
                ##trame_ppp.extend(adresse_D) <br>
                ##trame_ppp.extend(control) <br>
                ##trame_ppp.extend(protocol) <br> <br>

                #Affichage de la taille des éléments avant données <br>
                ##print("La taille de la trame avec les données est de ", len(trame_ppp), "bits.") <br><br>

                #Injection des données dans la trame <br>
                ##print(message_input_bin) <br>
                ##trame_ppp.extend(message_input_bin) <br><br>

                #Affichage de la taille des éléments avec données + données <br>
                ##print("La taille de la trame complète (avec données incluses) est de ", len(trame_structure), "bits.") <br><br>

                # Injection dans l'ordre des élements de la trame après les données dans la trame <br>
                ##trame_structure.extend(CRC) Non ajouté car le programme pour créer le CRC n'est pas fonctionnelle <br>
                ##trame_structure.extend(fanion) <br><br>
                                
                # affichage de la taille de la trame entière <br>
                ##print("La taille de la trame est de ",len(trame_ppp),"bits.") <br><br>
                                
                # Affichache de la trame <br>
                ##print("La trame finale à encoder est donc :",trame_ppp) <br>
            </code>

            <h3>Encodage NRZ</h3>
            <code>
                message_input_encode = [] <br><br>

                for i in range(0, len(message_input_bin)) : <br>
                    <blockquote>message_input_bin[i] == 1: </blockquote>
                    <blockquote><blockquote>message_input_encode.append(1) </blockquote></blockquote>
                    <blockquote>elif message_input_bin[i] == 0: </blockquote>
                    <blockquote><blockquote>message_input_encode.append(-1) </blockquote></blockquote><br>
                
                print(message_input_encode)
            </code>

            <h3>Modulation ASK</h3>
            <code>
                <pre>M = message_input_encode           #Message binaire M <br>Fe = 44100                         #Fréquence d'échantillonnage <br><br>baud = 16                          #Débit souhaité sur le canal de transmission exprimé en bit/s <br>Nbits = len(M)                     #Nombre de bits initial (taille du message M) <br>Ns = int(Fe/baud)                  #Nombre de symboles par bit (Fréquence d'échantillonnage / Débit binaire) <br>N = int(Nbits * Ns)                #Nombre de bits total à moduler (Nombre initial de bits * Nombre de symbole par bit) <br>print(Nbits) <br>print(N)</pre>
            </code>

            <p>
                Une fois les variables définies et initialisées, on peut rentrer dans la véritable fonction de
                modulation.
            </p>
            <code>
                m_encode_ASK = np.repeat(M, Ns) <br>
                #On peut aussi le faire avec la fonction tile de numpy : binaire = np.tile(bits,(1,Ns)) <br><br>

                #On génère le vecteur temps <br>
                t = np.linspace(0.0, N/Fe, N) <br>
                #On peut aussi le générer avec la commande arange : t = np.arange(0.0,N)/Fe <br><br>

                #On génère la porteuse P(t) <br>
                Ap = 1 <br>
                Fp = 2050 <br>
                Porteuse = Ap*np.sin(2*np.pi*Fp*t) <br><br>

                #On réalise la modulation en ampliture (ASK = porteuse * binaire) <br>
                ASK = m_encode_ASK*Porteuse <br><br>

                print(len(ASK)) <br><br>    

                #Affichage du message binaire, la porteuse, et le résultat de la modulation ASK <br>
                plt.figure(figsize = (10,6)) <br> 
                plt.plot(t, m_encode_ASK, 'black') <br>
                plt.xlabel('Temps [s]') <br>
                plt.title('Message binaire') <br> <br>

                plt.figure(figsize = (10,6)) <br>
                plt.plot(t, Porteuse, 'blue') <br>
                plt.xlabel('Temps [s]') <br>
                plt.title('Porteuse P(t)') <br> <br>

                plt.figure(figsize = (10,6)) <br>
                plt.plot(t, ASK, 'red') <br>
                plt.xlabel('Temps [s]') <br>
                plt.title('Modulation ASK') <br> <br>

                plt.show()
            </code>
        </section>

        <section id="section-projet-programme2">
            <h1>PROGRAMME DE L'ORDINATEUR RECEPTEUR</h1>
            <h3>Demodulation ASK</h3>
            <code>
                #temps pour un symbole <br>
                t = np.arange(0.0,N)/Fe <br><br>

                #Porteuse <br>
                Porteuse = np.sin(2*np.pi*Fp*t) <br><br>

                #Multiplier le signal modulé par la porteuse <br>
                Produit = ASK*Porteuse <br><br>

                print(len(Produit)) <br><br>

                #Intégration dans le résultat Démod sur la période de T = [0, Ns], Ns: taille du symbole par la méthode des Trapèzes <br><br>
                
                #Résultat de l'intégration <br>
                y = [] <br> <br>

                for i in range(0,N,Ns):
                <blockquote>y.append(np.trapz(Produit[i:i+Ns],t[i:i+Ns]))</blockquote> <br>

                print(len(y)) <br>
                print(y)
            </code>

            <h3>La comparaison</h3>
            <code>
                #Si y > 0 donc on a reçu 1 sinon c'est -1 <br>
                message_demodule = np.array(y) >= 0 <br>
                #Renvoie true si c'est supérieur à 0 sinon false <br>
                print(len(message_demodule)) <br>
                message_demodule_ASK = [] <br><br>

                for ii in range(0, len(message_demodule)):
                <blockquote>if message_demodule[ii] == False:</blockquote>
                <blockquote><blockquote>message_demodule_ASK.append(-1)</blockquote></blockquote>
                <blockquote>if message_demodule[ii] == True:</blockquote>
                <blockquote><blockquote>message_demodule_ASK.append(1)</blockquote></blockquote>
                print(message_demodule_ASK)
            </code>

            <h3>Decodage NRZ unipolaire</h3>
            <code>
                #Conversion binaire en string (char) <br>
                #On remet le message en suite de 0 et de 1 <br><br>

                message_demodule =  [] <br><br>

                #Boucle for parcourant le message démodulé par pas de 2 <br>
                for i in range(0, len(message_demodule_ASK)):
                <blockquote>if message_demodule_ASK[i] == 1:</blockquote>
                <blockquote><blockquote>message_demodule.append(1)</blockquote></blockquote>
                <blockquote>elif message_demodule_ASK[i] == -1:</blockquote>
                <blockquote><blockquote>message_demodule.append(0)</blockquote></blockquote>
                print(len(message_demodule)) <br>
                print(message_demodule)
            </code>

            <h3>Retirer la trame</h3>
            <code>
                ##del message_demodule[0:32] 
                ##del message_demodule[-8]
            </code>

            <h3>Binaire vers ASCII</h3>
            <code>
                #Ecrire la suite binaire du message dans une chaîne de caractères (char) <br>
                print(message_demodule) <br>
                bytes_lst = [] <br>
                for byte in [message_demodule[i:i+8] for i in range(0, len(message_demodule), 8)];
                <blockquote>bytes_lst.append(''.join([str(elem) for elem in byte]))</blockquote>
                data_reçu = ''.join([chr(int(byte, 2)) for byte in bytes_lst]) <br><br>

                print("Le message reçu comporte", len(bytes_lst),'caractères.') <br><br>

                #Affichage du résultat <br>
                print("Le message reçu est : ", data_reçu)
            </code>

            <h3 id="code-source">Lien vers le code source</h3>
    
            <div class="code-source">
                <img src="../img/icon-github.png" alt="Github icon">
                <a href="https://github.com/anais-mez/Message_code">Projet message codé</a>
            </div>
        </section>
    </main>

    <script src="../script/script.js"></script>
</body>

</html>